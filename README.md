# riri-mod-tools

[INSERT BANNER HERE]

A toolkit for writing Reloaded-II mods in Rust which exposes parts of the Reloaded mod loader API and C# which are usually [not available with native mods](https://reloaded-project.github.io/Reloaded-II/NativeMods/).

## Structure

A `riri-mod-tools` mod consists of a C# portion which contains the mod's entry point and handles certain backend tasks such as registering function hooks (this is a "normal" Reloaded mod) and a Rust portion which contains methods that either act as a payload for a certain function hook or are used in other mod loader actions such as `OnModLoading` or `OnModLoaderInitialized`.

While I haven't yet created a template for making `riri-mod-tools` projects, examples are available in [OpenGFD](https://github.com/rirurin/opengfd), [P5R Freecam](https://github.com/rirurin/p5r-freecam/) and [cri-adx-rs](https://github.com/rirurin/cri-adx-rs/).

For example, for the Metaphor portion of `OpenGFD`, the C# portion is in `metaphor.opengfd` and the Rust portion is in `opengfd-reloaded`. The Rust portion is the important part for mod authors since the majority of the C# portion is automatically generated by `opengfd-reloaded`'s build script.

`opengfd-reloaded`'s mod structure looks something like this:
```
opengfd-reloaded
    data
        modfiles
            ... # mod files (models, audio etc.) go here
        hashes.toml
        package.toml
    src
        ...
        lib.rs # root file for source code
        ...
    Cargo.toml # rust crate description (equivalent to csproj)
    build.rs
```

This is loosely based on [Reloaded3's specification](https://reloaded-project.github.io/Reloaded-III/Server/Packaging/About.html) for mod packages.
`package.toml` is `riri-mod-tools` equivalent to `ModConfig.json` and mostly follows the format of [Reloaded3's Package Metadata](https://reloaded-project.github.io/Reloaded-III/Server/Packaging/Package-Metadata.html):

```toml
Id = "metaphorrefantazio.mod.opengfd.riri" # Reloaded3 formatted mod ID, not used
Reloaded2Id = "metaphor.opengfd" # Mod ID that actually gets used
LoggerPrefix = "OpenGFD"
LoggerColor = "MediumTurquoise" # Web color, see https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/named-color
Name = "OpenGFD for Metaphor: Refantazio"
Author = "Rirurin"
PackageType = "Mod" # Always Mod
DocsFile = "index.html"
Tags = [ "deharcoding" ]
IsDependency = true
ClientSide = false

Icon = "icon.jxl" # Reloaded3 icon, not used
Reloaded2Icon = "Icon.png" # The icon that is used
SupportedGames = [ "metaphorrefantazio", "metaphor.exe" ] # Reloaded3 game ID + executable name

# These fields are imported from opengfd-reloaded's workspace Cargo.toml 
[CargoImport]
Summary = true
Version = true
SourceUrl = true
ProjectUrl = true

# Same as Reloaded3
[[Credits]]
Name = "Rirurin"
Role = "Main Developer"
Url = "https://riri.wtf"

[[Credits]]
Name = "Atlus/Studio Zero"
Role = "Making the game"

# Same as Reloaded3
[UpdateSourceData]
[UpdateSourceData.Gamebanana]
ItemType = "Mod"
ItemId = 559400

[UpdateSourceData.Github]
UserName = "Rirurin"
RepositoryName = "opengfd"

# Like Reloaded3, although these dependencies are marked as R2
[[R2Dependencies]]
Id = "mrfpc.modloader"
[R2Dependencies.UpdateSourceData]
[R2Dependencies.UpdateSourceData.Gamebanana]
ItemType = "Mod"
ItemId = 548481
[R2Dependencies.UpdateSourceData.Github]
UserName = "DeathChaos"
RepositoryName = "mrfpc.modloader"

# More dependencies defined here...

# Settings for function hook codegen
[HookSettings]
HookLibrary = "Reloaded2CSharpHooks"
DefaultCallingConvention = "Microsoft"
```

## Function Hooks

Reloaded function hooks can be fully defined within Rust, where the hook payload is the function that the definition is attached to. An example is shown below:

```rust
#[riri_hook_fn(dynamic_offset(
    signature = "40 53 48 83 EC 50 48 8B 59 ?? 0F 29 74 24 ?? 0F 28 F1",
    resolve_type = setfldPCMoveUpdate,
    calling_convention = "microsoft",
))]
pub unsafe extern "C" fn fldPCMoveUpdate(p_task: *mut u8, delta: f32) {
    if !Freecam::check_active() {
        let _ = original_function!(p_task, delta);
    }
}
```

Likewise, a reference to a global can be defined using the same syntax:

```rust
#[riri_hook_static(dynamic_offset(
    signature = "48 8D 2D ?? ?? ?? ?? 66 21 83 ?? ?? ?? ??",
    resolve_type = setfldProcTable,
    calling_convention = "microsoft",
))]
riri_static!(FLD_PROC_TABLE, usize);
```

The syntax consists of `riri_hook_fn` or `riri_hook_static` to denote the type of object we're referencing, then a hooking method:

### `static_offset`

`static_offset` uses a fixed address relative to the beginning of the executable (e.g `riri_hook_fn(static_offset(0x147c470))`). `dynamic_offset` should always be used instead.

### `dynamic_offset`

`dynamic_offset` utilizes Reloaded's fast signature scanning library to find a function from a sequence of bytes (the `signature` field).

`calling_convention` defines how the function's parameters are added to the registers/stack before calling the function itself. For MSVC compiled games on x86_64 this will be `Microsoft` (params are added into rcx/xmm0, rdx/xmm1, r8/xmm2, r9/xmm3, then the stack starting at `rsp + 0x28`)

`resolve_type` is a reference to the function that handles the result of a sigscan and gets the final address from it. For `fldPCMoveUpdate`, this resolve function is `setfldPCMoveUpdate`, which is

```rust
// ofs is an offset relative to the start of the executable
#[no_mangle]
pub unsafe extern "C" fn setfldPCMoveUpdate(ofs: usize) -> Option<NonNull<u8>> {
    let addr = match sigscan_resolver::get_address_may_thunk(ofs) {
        Some(v) => v, None => return None
    };
    logln!(Information, "got fldPCMoveUpdate: 0x{:x}", addr.as_ptr() as usize);
    Some(addr)
}
```

`riri_mod_tools_rt::sigscan_resolver` contains a set of resolver functions for getting a final address from some offset or absolute address:
- `get_address(ofs: usize) -> NonNull<u8>` - get an absolute address from a relative address. Use `get_address_may_thunk` instead.
- `get_address_may_thunk(ofs: usize) -> CanNull` - `get_address` but it traverse to an inner function if the current function is a thunk (a single jump instruction to the inner function).
- `get_address_may_thunk_absolute(addr: usize) -> CanNull` - like `get_address_may_thunk` but as an absolute address instead of an offset from exe
- `get_indirect_address_short(ofs: usize) -> CanNull` - dereference a near pointer within an instruction which starts at the second byte, such as in a `CALL` instruction.
- `get_indirect_address_short_abs(addr: *mut u8) -> CanNull` - ditto, but absolute
- `get_indirect_address_short2(ofs: usize) -> CanNull` - dereference a near pointer within an instruction which starts at the third byte, such as in a `TEST` instruction.
- `get_indirect_address_short2_abs(ofs: usize) -> CanNull` - ditto, but absolute
- `get_indirect_address_long(ofs: usize) -> CanNull` - dereference a near pointer within an instruction which starts at the fourth byte, such as in a `MOV` instruction.
- `get_indirect_address_long_abs(ofs: usize) -> CanNull` - ditto, but absolute
- `get_indirect_address_long4(ofs: usize) -> CanNull` - dereference a near pointer within an instruction which starts at the fifth byte.
- `get_indirect_address_long4_abs(ofs: usize) -> CanNull` - ditto, but absolute

The `signature` field can be omitted if `shared_scan = "consumer"`. This is used for signatures which are defined in a dependency mod and it's result shared to other mods using [SharedScans](https://github.com/RyoTune/SharedScans):

```rust
#[riri_hook_static(dynamic_offset(
    resolve_type = set_criAtomExPlayer_Create,
    calling_convention = "microsoft",
    shared_scan = "consumer"
))]
riri_static!(criAtomExPlayer_Create, usize);
```

### `user_defined`

`user_defined` sets up the internal structures needed to make a function hook but doesn't activate one until the mod creator's code specifies it with a `create_hook!()`. For example,

```rust
#[riri_hook_fn(user_defined())]
pub unsafe extern "C" fn print_log(text: *mut u8) {
    let text = unsafe { std::ffi::CStr::from_ptr(text as *mut i8).to_str().unwrap() };
    log_noprefix!(Verbose, "{}", text);
}
```

...which  hooks onto the `PrintLog` squirrel function defined in Metaphor waits until `sq_newclosure` is used to register `PrintLog`, where the hook is activated:

```rust
match name.get_str() {
    "PrintLog" => {
        if HOOKED_PRINT_LOG.get().is_none() {
            let ptr = user_data.get_user_function_pointer() as usize;
            create_hook!(ptr, print_log);
            logln!(Verbose, "PrintLog function: 0x{:x}", ptr);
            let _ = HOOKED_PRINT_LOG.set(());
        }
    },
    _ => ()
}
```

Unlike `static_offset` or `dynamic_offset` which are run before the game is started, `user_defined` can be activated at any time during the game's execution.

### Defining Multiple Hook Types

In situations where there needs to be some difference in how a hook is constructed for a given game version (e.g the signature breaks on a given version), multiple hook types can be defined using Rust's `match` syntax to match to a given executable hash:

```
[riri_hook_*({
    HASH0 => dynamic_offset(...),
    # or for matching multiple hashes
    HASH1 | HASH2 => dynamic_offset(...),
    # Default case
    _ => dynamic_offset(...)
})]
```

e.g

```rust
#[riri_hook_static({
    XRD759_UWP_1011 => dynamic_offset(
        signature = "4C 8D 35 ?? ?? ?? ?? 4C 89 7C 24 ?? 41 BF 00 00 4D 8F",
        resolve_type = set_gfd_job_list_hook,
        calling_convention = "microsoft",
    ),
    _ => dynamic_offset(
        signature = "4C 8D 35 ?? ?? ?? ?? 4C 89 7C 24 ?? 41 BF 00 00 00 80",
        resolve_type = set_gfd_job_list_hook,
        calling_convention = "microsoft",
    )
})]
riri_static!(GFD_JOB_LIST, usize);
```

### Mid Function Hooks

Mid-function hooks can be defined using `riri_hook_inline_fn`. The syntax consists of the following:
```c#
#[riri_hook_inline_fn(
    dynamic_offset(...), // like with other hooks
    [
        ExecuteFirst, // hook execution order
        [rbx, rcx], rax, // parameter registers, return register
        [], false, // callee saved registers, allocate shadow space
        None, // insert custom assembly before
        // insert custom assembly after
        "$\"test al, al\",\n\ 
        $\"jnz hookEnd\",\n\
        $\"xor eax, eax\",\n\
        $\"add rsp, 32\",\n\
        $\"pop rbx\",\n\
        $\"ret\",\n\
        $\"label hookEnd\",\n"
    ]
)]
```

For reference, `riri-mod-tools` codegen will generate the following data in the C# portion of the mod:

```c#
// ...
private Reloaded.Hooks.Definitions.IAsmHook? _saveDataLoadByFileWorkerWaitForServer_ASM;
private Reloaded.Hooks.Definitions.IReverseWrapper<metaphor.multiplayer.ReloadedFFI.Hooks.Hooks_715B6A9B9067003A.saveDataLoadByFileWorkerWaitForServerDelegate>? _saveDataLoadByFileWorkerWaitForServer_WRAPXRD759_STEAM_1013;
// ...
// In RegisterHooks_715B6A9B9067003A:
// ...
SigScan("...", "saveDataLoadByFileWorkerWaitForServer", x => {
    var addr = metaphor.multiplayer.ReloadedFFI.Hooks.Hooks_715B6A9B9067003A.set_save_data_wait_for_server(x);
string[] function = 
{
    "use64",
    // If we had defined any custom assembly before the hook, this would go here

    // Create the assembly instructions needed to call the Rust function.
    // See https://reloaded-project.github.io/Reloaded.Hooks/GettingStarted/#in-assembly-code
    $"{_hooks!.Utilities.GetAbsoluteCallMnemonics(metaphor.multiplayer.ReloadedFFI.Hooks.Hooks_715B6A9B9067003A.saveDataLoadByFileWorkerWaitForServer, out _saveDataLoadByFileWorkerWaitForServer_WRAPXRD759_STEAM_1013)}",
    $"test al, al",
    $"jnz hookEnd",
    $"xor eax, eax",
    $"add rsp, 32",
    $"pop rbx",
    $"ret",
    $"label hookEnd",
};
_saveDataLoadByFileWorkerWaitForServer_ASM = _hooks!.CreateAsmHook(function, (long)addr, Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour.ExecuteFirst).Activate();
});
```

## Process Info

[TODO]

## VTable Utilities

[TODO]

## Interop with C# Types

[TODO]