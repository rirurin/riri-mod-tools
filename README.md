# riri-mod-tools

[INSERT BANNER HERE]

A toolkit for writing Reloaded-II mods in Rust which exposes parts of the Reloaded mod loader API and C# which are usually [not available with native mods](https://reloaded-project.github.io/Reloaded-II/NativeMods/).

## Structure

A `riri-mod-tools` mod consists of a C# portion which contains the mod's entry point and handles certain backend tasks such as registering function hooks (this is a "normal" Reloaded mod) and a Rust portion which contains methods that either act as a payload for a certain function hook or are used in other mod loader actions such as `OnModLoading` or `OnModLoaderInitialized`.

While I haven't yet created a template for making `riri-mod-tools` projects, examples are available in [OpenGFD](https://github.com/rirurin/opengfd), [P5R Freecam](https://github.com/rirurin/p5r-freecam/) and [cri-adx-rs](https://github.com/rirurin/cri-adx-rs/).

For example, for the Metaphor portion of `OpenGFD`, the C# portion is in `metaphor.opengfd` and the Rust portion is in `opengfd-reloaded`. The Rust portion is the important part for mod authors since the majority of the C# portion is automatically generated by `opengfd-reloaded`'s build script.

`opengfd-reloaded`'s mod structure looks something like this:
```
opengfd-reloaded
    data
        modfiles
            ... # mod files (models, audio etc.) go here
        hashes.toml
        package.toml
    src
        ...
        lib.rs # root file for source code
        ...
    Cargo.toml # rust crate description (equivalent to csproj)
    build.rs
```

This is loosely based on [Reloaded3's specification](https://reloaded-project.github.io/Reloaded-III/Server/Packaging/About.html) for mod packages.
`package.toml` is `riri-mod-tools` equivalent to `ModConfig.json` and mostly follows the format of [Reloaded3's Package Metadata](https://reloaded-project.github.io/Reloaded-III/Server/Packaging/Package-Metadata.html):

```toml
Id = "metaphorrefantazio.mod.opengfd.riri" # Reloaded3 formatted mod ID, not used
Reloaded2Id = "metaphor.opengfd" # Mod ID that actually gets used
LoggerPrefix = "OpenGFD"
LoggerColor = "MediumTurquoise" # Web color, see https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Values/named-color
Name = "OpenGFD for Metaphor: Refantazio"
Author = "Rirurin"
PackageType = "Mod" # Always Mod
DocsFile = "index.html"
Tags = [ "deharcoding" ]
IsDependency = true
ClientSide = false
UseCsharpInvocation = true # (Optional) Allows use of auto-generated bindings to C# Reloaded-II interfaces (see riri_mod_tools_rt::reloaded::mod::interfaces)
UseCachedSignatures = true # (Optional) Caches signatures so sigscanning isn't required as long as the executable and the order and version of active mods remain the same.

Icon = "icon.jxl" # Reloaded3 icon, not used
Reloaded2Icon = "Icon.png" # The icon that is used
SupportedGames = [ "metaphorrefantazio", "metaphor.exe" ] # Reloaded3 game ID + executable name

# These fields are imported from opengfd-reloaded's workspace Cargo.toml 
[CargoImport]
Summary = true
Version = true
SourceUrl = true
ProjectUrl = true

# Same as Reloaded3
[[Credits]]
Name = "Rirurin"
Role = "Main Developer"
Url = "https://riri.wtf"

[[Credits]]
Name = "Atlus/Studio Zero"
Role = "Making the game"

# Same as Reloaded3
[UpdateSourceData]
[UpdateSourceData.Gamebanana]
ItemType = "Mod"
ItemId = 559400

[UpdateSourceData.Github]
UserName = "Rirurin"
RepositoryName = "opengfd"

# Like Reloaded3, although these dependencies are marked as R2
[[R2Dependencies]]
Id = "mrfpc.modloader"
[R2Dependencies.UpdateSourceData]
[R2Dependencies.UpdateSourceData.Gamebanana]
ItemType = "Mod"
ItemId = 548481
[R2Dependencies.UpdateSourceData.Github]
UserName = "DeathChaos"
RepositoryName = "mrfpc.modloader"

# More dependencies defined here...

# Settings for function hook codegen
[HookSettings]
HookLibrary = "Reloaded2CSharpHooks"
DefaultCallingConvention = "Microsoft"
```

### Mod Runtime

For Reloaded mods, this library should be used with the `reloaded` feature enabled, which will assume a Reloaded-II runtime. **Riri Mod Runtime** (`riri_mod_runtime_reloaded`) is a mod dependency that provides a cached Xxh3 hash of the unmodified executable and stores a list of all type names obtained from RTTI.

This library can be also be used without `reloaded` if you want to use the crate's logger features on a regular Rust crate.

## Function Hooks

Reloaded function hooks can be fully defined within Rust, where the hook payload is the function that the definition is attached to. An example is shown below:

```rust
#[riri_hook_fn(dynamic_offset(
    signature = "40 53 48 83 EC 50 48 8B 59 ?? 0F 29 74 24 ?? 0F 28 F1",
    resolve_type = setfldPCMoveUpdate,
    calling_convention = "microsoft",
))]
pub unsafe extern "C" fn fldPCMoveUpdate(p_task: *mut u8, delta: f32) {
    if !Freecam::check_active() {
        let _ = original_function!(p_task, delta);
    }
}
```

Likewise, a reference to a global can be defined using the same syntax:

```rust
#[riri_hook_static(dynamic_offset(
    signature = "48 8D 2D ?? ?? ?? ?? 66 21 83 ?? ?? ?? ??",
    resolve_type = setfldProcTable,
    calling_convention = "microsoft",
))]
riri_static!(FLD_PROC_TABLE, usize);
```

The syntax consists of `riri_hook_fn` or `riri_hook_static` to denote the type of object we're referencing, then a hooking method:

### `static_offset`

`static_offset` uses a fixed address relative to the beginning of the executable (e.g `riri_hook_fn(static_offset(0x147c470))`). 
This method only exists for testing. In practice, `dynamic_offset` should always be used instead since it can find a sequence of bytes anywhere within the executable, which makes it resistant against updates which will move code around.

### `dynamic_offset`

`dynamic_offset` utilizes Reloaded's fast signature scanning library to find a function from a sequence of bytes (the `signature` field).

`calling_convention` defines how the function's parameters are added to the registers/stack before calling the function itself. For MSVC compiled games on x86_64 this will be `Microsoft` (params are added into rcx/xmm0, rdx/xmm1, r8/xmm2, r9/xmm3, then the stack starting at `rsp + 0x28`)

`resolve_type` is a reference to the function that handles the result of a sigscan and gets the final address from it. For `fldPCMoveUpdate`, this resolve function is `setfldPCMoveUpdate`, which is

```rust
// ofs is an offset relative to the start of the executable
#[no_mangle]
pub unsafe extern "C" fn setfldPCMoveUpdate(ofs: usize) -> Option<NonNull<u8>> {
    let addr = match sigscan_resolver::get_address_may_thunk(ofs) {
        Some(v) => v, None => return None
    };
    logln!(Information, "got fldPCMoveUpdate: 0x{:x}", addr.as_ptr() as usize);
    Some(addr)
}
```

`riri_mod_tools_rt::sigscan_resolver` contains a set of resolver functions for getting a final address from some offset or absolute address:
- `get_address(ofs: usize) -> NonNull<u8>` - get an absolute address from a relative address. Use `get_address_may_thunk` instead.
- `get_address_may_thunk(ofs: usize) -> CanNull` - `get_address` but it traverse to an inner function if the current function is a thunk (a single jump instruction to the inner function).
- `get_address_may_thunk_absolute(addr: usize) -> CanNull` - like `get_address_may_thunk` but as an absolute address instead of an offset from exe
- `get_indirect_address_short(ofs: usize) -> CanNull` - dereference a near pointer within an instruction which starts at the second byte, such as in a `CALL` instruction.
- `get_indirect_address_short_abs(addr: *mut u8) -> CanNull` - ditto, but absolute
- `get_indirect_address_short2(ofs: usize) -> CanNull` - dereference a near pointer within an instruction which starts at the third byte, such as in a `TEST` instruction.
- `get_indirect_address_short2_abs(ofs: usize) -> CanNull` - ditto, but absolute
- `get_indirect_address_long(ofs: usize) -> CanNull` - dereference a near pointer within an instruction which starts at the fourth byte, such as in a `MOV` instruction.
- `get_indirect_address_long_abs(ofs: usize) -> CanNull` - ditto, but absolute
- `get_indirect_address_long4(ofs: usize) -> CanNull` - dereference a near pointer within an instruction which starts at the fifth byte.
- `get_indirect_address_long4_abs(ofs: usize) -> CanNull` - ditto, but absolute

The `signature` field can be omitted if `shared_scan = "consumer"`. This is used for signatures which are defined in a dependency mod and it's result shared to other mods using [SharedScans](https://github.com/RyoTune/SharedScans):

```rust
#[riri_hook_static(dynamic_offset(
    resolve_type = set_criAtomExPlayer_Create,
    calling_convention = "microsoft",
    shared_scan = "consumer"
))]
riri_static!(criAtomExPlayer_Create, usize);
```

### `user_defined`

`user_defined` sets up the internal structures needed to make a function hook but doesn't activate one until the mod creator's code specifies it with a `create_hook!()`. For example,

```rust
#[riri_hook_fn(user_defined())]
pub unsafe extern "C" fn print_log(text: *mut u8) {
    let text = unsafe { std::ffi::CStr::from_ptr(text as *mut i8).to_str().unwrap() };
    log_noprefix!(Verbose, "{}", text);
}
```

...which  hooks onto the `PrintLog` squirrel function defined in Metaphor waits until `sq_newclosure` is used to register `PrintLog`, where the hook is activated:

```rust
match name.get_str() {
    "PrintLog" => {
        if HOOKED_PRINT_LOG.get().is_none() {
            let ptr = user_data.get_user_function_pointer() as usize;
            create_hook!(ptr, print_log);
            logln!(Verbose, "PrintLog function: 0x{:x}", ptr);
            let _ = HOOKED_PRINT_LOG.set(());
        }
    },
    _ => ()
}
```

Unlike `static_offset` or `dynamic_offset` which are run before the game is started, `user_defined` can be activated at any time during the game's execution.

### Defining Multiple Hook Types

In situations where there needs to be some difference in how a hook is constructed for a given game version (e.g the signature breaks on a given version), multiple hook types can be defined using Rust's `match` syntax to match to a given executable hash:

```
[riri_hook_*({
    HASH0 => dynamic_offset(...),
    # or for matching multiple hashes
    HASH1 | HASH2 => dynamic_offset(...),
    # Default case
    _ => dynamic_offset(...)
})]
```

e.g

```rust
#[riri_hook_static({
    XRD759_UWP_1011 => dynamic_offset(
        signature = "4C 8D 35 ?? ?? ?? ?? 4C 89 7C 24 ?? 41 BF 00 00 4D 8F",
        resolve_type = set_gfd_job_list_hook,
        calling_convention = "microsoft",
    ),
    _ => dynamic_offset(
        signature = "4C 8D 35 ?? ?? ?? ?? 4C 89 7C 24 ?? 41 BF 00 00 00 80",
        resolve_type = set_gfd_job_list_hook,
        calling_convention = "microsoft",
    )
})]
riri_static!(GFD_JOB_LIST, usize);
```

### Mid Function Hooks

Mid-function hooks can be defined using `riri_hook_inline_fn`. The syntax consists of the following:
```c#
#[riri_hook_inline_fn(
    dynamic_offset(...), // like with other hooks
    [
        ExecuteFirst, // hook execution order
        [rbx, rcx], rax, // parameter registers, return register
        [], false, // callee saved registers, allocate shadow space
        None, // insert custom assembly before
        // insert custom assembly after
        "$\"test al, al\",\n\ 
        $\"jnz hookEnd\",\n\
        $\"xor eax, eax\",\n\
        $\"add rsp, 32\",\n\
        $\"pop rbx\",\n\
        $\"ret\",\n\
        $\"label hookEnd\",\n"
    ]
)]
```

For reference, `riri-mod-tools` codegen will generate the following data in the C# portion of the mod:

```c#
// ...
private Reloaded.Hooks.Definitions.IAsmHook? _saveDataLoadByFileWorkerWaitForServer_ASM;
private Reloaded.Hooks.Definitions.IReverseWrapper<metaphor.multiplayer.ReloadedFFI.Hooks.Hooks_715B6A9B9067003A.saveDataLoadByFileWorkerWaitForServerDelegate>? _saveDataLoadByFileWorkerWaitForServer_WRAPXRD759_STEAM_1013;
// ...
// In RegisterHooks_715B6A9B9067003A:
// ...
SigScan("...", "saveDataLoadByFileWorkerWaitForServer", x => {
    var addr = metaphor.multiplayer.ReloadedFFI.Hooks.Hooks_715B6A9B9067003A.set_save_data_wait_for_server(x);
string[] function = 
{
    "use64",
    // If we had defined any custom assembly before the hook, this would go here

    // Create the assembly instructions needed to call the Rust function.
    // See https://reloaded-project.github.io/Reloaded.Hooks/GettingStarted/#in-assembly-code
    $"{_hooks!.Utilities.GetAbsoluteCallMnemonics(metaphor.multiplayer.ReloadedFFI.Hooks.Hooks_715B6A9B9067003A.saveDataLoadByFileWorkerWaitForServer, out _saveDataLoadByFileWorkerWaitForServer_WRAPXRD759_STEAM_1013)}",
    $"test al, al",
    $"jnz hookEnd",
    $"xor eax, eax",
    $"add rsp, 32",
    $"pop rbx",
    $"ret",
    $"label hookEnd",
};
_saveDataLoadByFileWorkerWaitForServer_ASM = _hooks!.CreateAsmHook(function, (long)addr, Reloaded.Hooks.Definitions.Enums.AsmHookBehaviour.ExecuteFirst).Activate();
});
```

## Process Info

A struct that provides methods for extracting certain info from the game's executable. The ProcessInfo for the game can be retrieved using `ProcessInfo::get_current_process`.

The most useful methods are listed below:

#### `change_protection`

Sets the protection for a segment of memory to the specified `PageProtection` bitflag value. \
The following enables read, write and execute to write a custom short `jmp`:

```rust
let jmp_patch: [u8; 2] = [0xeb, dist];
let mut process = ProcessInfo::get_current_process().unwrap();
process.change_protection(std::slice::from_raw_parts(addr.as_ptr(), 2), PageProtection::all());
std::ptr::copy_nonoverlapping(jmp_patch.as_ptr(), addr.as_ptr(), 2);
```

On Windows, PageProtection is converted into the equivalent [Win32's memory protection constant](https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants) and used on [VirtualProtectEx](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotectex). \
On Linux, [mprotect](https://man7.org/linux/man-pages/man2/mprotect.2.html) is called. PageProtection's bitflag matches `prot`'s bitflag layout.

*Note: Before 0.3.0, `change_protection_raw` was used instead which directly called the Windows implementation. `change_protection` should be used instead for Linux support.*

#### `get_executable_address`

Gets the base address for the game's executable.

On Windows, this is the value of `HMODULE`. On Linux, this is obtained from `dl_phdr_info.base_address`

#### `get_executable_size`

Gets the size of the game's executable.

On Windows, this is obtained from `MODULEINFO.SizeOfImage`. On Linux, this is obtained from the largest `p_vaddr + p_memsz` in the executable's memory section.

#### `get_executable_hash`

Gets the Xxh3 hash for the game's executable. This method is only functional on Windows with the `reloaded` feature, which will call `get_executable_hash_ex` from `riri_mod_runtime_reloaded`.\
This is useful in cases where a certain game version requires different parameters when doing operations such as memory patching.

## VTable Utilities

Provides functions for interacting with C++ vtables which are exposed to RTTI. This currently only works with MSVC compiled games.

#### `get_vtable`

Get the address to the start of the vtable from the given name. \
The following gets the address for `app::msg::Manager::Message`:

```rust
let message_vtable = riri_mod_tools_rt::vtable::get_vtable("Message@Manager@msg@app@@");
```

If the vtable could not be found, the address will be null.

#### `get_vtable_with_offset`

`get_vtable` but with an offset to get a specific function. (e.g `get_vtable_with_offset("name", 2)` will get the third function in the vtable). \
There is no bounds checking, it's assumed that you know how long the vtable for a particular class is.

#### `replace_vtable_method`

Writes a custom function into the vtable at the specified method index. \
If you intend on calling the original function, store the pointer to the original function using your callback in `handle_original`.

The following is an example of a function hook onto `tick` in `app::ui::TitleLayout`'s vtable which calls the original function:

```rust

#[riri_mods_loaded_fn]
fn hook_existing_game_ui_components() {
    // layout draw methods
    riri_mod_tools_rt::vtable::replace_vtable_method("TitleLayout@ui@app@@", 2, |f| {
        TitleLayout::set_tick_function(unsafe { std::mem::transmute::<_, extern "C" fn(&mut TitleLayout)>(f) });
    }, TitleLayout::tick as usize);
    // ...
}

// ...

static ORIGINAL_TITLE_LAYOUT_TICK: OnceLock<extern "C" fn(&mut TitleLayout)> = OnceLock::new();

// ...

impl TitleLayout {
    pub fn set_tick_function(func: extern "C" fn(&mut TitleLayout)) {
        let _ = ORIGINAL_TITLE_LAYOUT_TICK.set(func);
    }

    pub fn tick(&mut self) {
        // get project stream (title_menu.ssbp)
        if let Some(proj) = self.get_menu_mut().get_base_pane_mut().get_player_mut().get_project_data_mut() {
            // ...
        }
        ORIGINAL_TITLE_LAYOUT_TICK.get().unwrap()(self);
    }
}
```

## Interop with C# Types

If `UseCsharpInvocation` is true in `package.toml`, the mod's auto-generated C# code will include structures to allow for the creation of basic C# types, the retrieval of certain Reloaded singletons and the invocation of methods associated with those given types.

For now, only a few select methods are available in `reloaded::mod::interfaces` from the IModConfig interface for getting the mod's name, author and version. In future releases, this will be expanded to include more methods.